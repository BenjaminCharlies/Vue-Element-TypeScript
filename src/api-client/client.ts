/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.1.6.0 (NJsonSchema v10.0.28.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ApplicationClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    searchAll(sessionId: string | null | undefined, applicationIdOrNameOrMobile: string | null | undefined, status: ApplicationStatus | null | undefined, subjectId: string | null | undefined, registrationStartDate: Date | null | undefined, registrationEndDate: Date | null | undefined, examStartDate: Date | null | undefined, examEndDate: Date | null | undefined, applicationSendEmailStatus: ApplicationSendEmailStatus | null | undefined, officeId: string | null | undefined, cityId: string | null | undefined, productId: string | null | undefined, examDate: Date | null | undefined, isUnderEighteen: boolean | null | undefined, refundStatus: ApplicationRefundStatus | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfApplicationListModel> {
        let url_ = this.baseUrl + "/api/application/search?";
        if (sessionId !== undefined)
            url_ += "SessionId=" + encodeURIComponent("" + sessionId) + "&"; 
        if (applicationIdOrNameOrMobile !== undefined)
            url_ += "ApplicationIdOrNameOrMobile=" + encodeURIComponent("" + applicationIdOrNameOrMobile) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (subjectId !== undefined)
            url_ += "SubjectId=" + encodeURIComponent("" + subjectId) + "&"; 
        if (registrationStartDate !== undefined)
            url_ += "RegistrationStartDate=" + encodeURIComponent(registrationStartDate ? "" + registrationStartDate.toJSON() : "") + "&"; 
        if (registrationEndDate !== undefined)
            url_ += "RegistrationEndDate=" + encodeURIComponent(registrationEndDate ? "" + registrationEndDate.toJSON() : "") + "&"; 
        if (examStartDate !== undefined)
            url_ += "ExamStartDate=" + encodeURIComponent(examStartDate ? "" + examStartDate.toJSON() : "") + "&"; 
        if (examEndDate !== undefined)
            url_ += "ExamEndDate=" + encodeURIComponent(examEndDate ? "" + examEndDate.toJSON() : "") + "&"; 
        if (applicationSendEmailStatus !== undefined)
            url_ += "ApplicationSendEmailStatus=" + encodeURIComponent("" + applicationSendEmailStatus) + "&"; 
        if (officeId !== undefined)
            url_ += "OfficeId=" + encodeURIComponent("" + officeId) + "&"; 
        if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&"; 
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&"; 
        if (examDate !== undefined)
            url_ += "ExamDate=" + encodeURIComponent(examDate ? "" + examDate.toJSON() : "") + "&"; 
        if (isUnderEighteen !== undefined)
            url_ += "IsUnderEighteen=" + encodeURIComponent("" + isUnderEighteen) + "&"; 
        if (refundStatus !== undefined)
            url_ += "RefundStatus=" + encodeURIComponent("" + refundStatus) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchAll(_response);
        });
    }

    protected processSearchAll(response: Response): Promise<PagedResultOfApplicationListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfApplicationListModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfApplicationListModel>(<any>null);
    }

    modify(model: ApplicationModel): Promise<ApplicationModel> {
        let url_ = this.baseUrl + "/api/application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModify(_response);
        });
    }

    protected processModify(response: Response): Promise<ApplicationModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationModel>(<any>null);
    }

    getById(id: string): Promise<ApplicationDetailModel> {
        let url_ = this.baseUrl + "/api/application/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<ApplicationDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationDetailModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationDetailModel>(<any>null);
    }

    updateStatus(model: UpdateApplicationStatusModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/application/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    downloadU18ExcelBySessionId(sessionId: string | undefined): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/application/session/u18?";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDownloadU18ExcelBySessionId(_response);
        });
    }

    protected processDownloadU18ExcelBySessionId(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    sendEmail(applicationid: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/application/sendemail/{applicationid}";
        if (applicationid === undefined || applicationid === null)
            throw new Error("The parameter 'applicationid' must be defined.");
        url_ = url_.replace("{applicationid}", encodeURIComponent("" + applicationid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendEmail(_response);
        });
    }

    protected processSendEmail(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    searchUnderSession(sessionId: string | null | undefined, applicationIdOrNameOrMobile: string | null | undefined, status: ApplicationStatus | null | undefined, subjectId: string | null | undefined, registrationStartDate: Date | null | undefined, registrationEndDate: Date | null | undefined, examStartDate: Date | null | undefined, examEndDate: Date | null | undefined, applicationSendEmailStatus: ApplicationSendEmailStatus | null | undefined, officeId: string | null | undefined, cityId: string | null | undefined, productId: string | null | undefined, examDate: Date | null | undefined, isUnderEighteen: boolean | null | undefined, refundStatus: ApplicationRefundStatus | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfApplicationListModel> {
        let url_ = this.baseUrl + "/api/application/session/search?";
        if (sessionId !== undefined)
            url_ += "SessionId=" + encodeURIComponent("" + sessionId) + "&"; 
        if (applicationIdOrNameOrMobile !== undefined)
            url_ += "ApplicationIdOrNameOrMobile=" + encodeURIComponent("" + applicationIdOrNameOrMobile) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (subjectId !== undefined)
            url_ += "SubjectId=" + encodeURIComponent("" + subjectId) + "&"; 
        if (registrationStartDate !== undefined)
            url_ += "RegistrationStartDate=" + encodeURIComponent(registrationStartDate ? "" + registrationStartDate.toJSON() : "") + "&"; 
        if (registrationEndDate !== undefined)
            url_ += "RegistrationEndDate=" + encodeURIComponent(registrationEndDate ? "" + registrationEndDate.toJSON() : "") + "&"; 
        if (examStartDate !== undefined)
            url_ += "ExamStartDate=" + encodeURIComponent(examStartDate ? "" + examStartDate.toJSON() : "") + "&"; 
        if (examEndDate !== undefined)
            url_ += "ExamEndDate=" + encodeURIComponent(examEndDate ? "" + examEndDate.toJSON() : "") + "&"; 
        if (applicationSendEmailStatus !== undefined)
            url_ += "ApplicationSendEmailStatus=" + encodeURIComponent("" + applicationSendEmailStatus) + "&"; 
        if (officeId !== undefined)
            url_ += "OfficeId=" + encodeURIComponent("" + officeId) + "&"; 
        if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&"; 
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&"; 
        if (examDate !== undefined)
            url_ += "ExamDate=" + encodeURIComponent(examDate ? "" + examDate.toJSON() : "") + "&"; 
        if (isUnderEighteen !== undefined)
            url_ += "IsUnderEighteen=" + encodeURIComponent("" + isUnderEighteen) + "&"; 
        if (refundStatus !== undefined)
            url_ += "RefundStatus=" + encodeURIComponent("" + refundStatus) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearchUnderSession(_response);
        });
    }

    protected processSearchUnderSession(response: Response): Promise<PagedResultOfApplicationListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfApplicationListModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfApplicationListModel>(<any>null);
    }
}

export class AuthClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    authenticate(loginType: LoginType | undefined, mobile: string | null | undefined, mobileOrEmail: string | null | undefined, password: string | null | undefined, verificationCode: string | null | undefined): Promise<AdminUserModel> {
        let url_ = this.baseUrl + "/api/auth/auth?";
        if (loginType === null)
            throw new Error("The parameter 'loginType' cannot be null.");
        else if (loginType !== undefined)
            url_ += "LoginType=" + encodeURIComponent("" + loginType) + "&"; 
        if (mobile !== undefined)
            url_ += "Mobile=" + encodeURIComponent("" + mobile) + "&"; 
        if (mobileOrEmail !== undefined)
            url_ += "MobileOrEmail=" + encodeURIComponent("" + mobileOrEmail) + "&"; 
        if (password !== undefined)
            url_ += "Password=" + encodeURIComponent("" + password) + "&"; 
        if (verificationCode !== undefined)
            url_ += "VerificationCode=" + encodeURIComponent("" + verificationCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAuthenticate(_response);
        });
    }

    protected processAuthenticate(response: Response): Promise<AdminUserModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AdminUserModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AdminUserModel>(<any>null);
    }

    out(): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/out";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOut(_response);
        });
    }

    protected processOut(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class CityClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    getAll(productId: string | null | undefined): Promise<CityModel[]> {
        let url_ = this.baseUrl + "/api/city/all?";
        if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<CityModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CityModel[]>(<any>null);
    }

    getUnderSession(subjectId: string): Promise<CityModel[]> {
        let url_ = this.baseUrl + "/api/city/subject/{subjectId}";
        if (subjectId === undefined || subjectId === null)
            throw new Error("The parameter 'subjectId' must be defined.");
        url_ = url_.replace("{subjectId}", encodeURIComponent("" + subjectId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUnderSession(_response);
        });
    }

    protected processGetUnderSession(response: Response): Promise<CityModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CityModel[]>(<any>null);
    }

    getByOfficeId(officeid: string): Promise<CityModel[]> {
        let url_ = this.baseUrl + "/api/city/office/{officeid}";
        if (officeid === undefined || officeid === null)
            throw new Error("The parameter 'officeid' must be defined.");
        url_ = url_.replace("{officeid}", encodeURIComponent("" + officeid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByOfficeId(_response);
        });
    }

    protected processGetByOfficeId(response: Response): Promise<CityModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CityModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CityModel[]>(<any>null);
    }
}

export class FeeMatrixClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    add(model: FeeMatrixModel): Promise<FeeMatrixModel> {
        let url_ = this.baseUrl + "/api/feematrix";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<FeeMatrixModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeeMatrixModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FeeMatrixModel>(<any>null);
    }

    modify(model: FeeMatrixModel): Promise<FeeMatrixModel> {
        let url_ = this.baseUrl + "/api/feematrix";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModify(_response);
        });
    }

    protected processModify(response: Response): Promise<FeeMatrixModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeeMatrixModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FeeMatrixModel>(<any>null);
    }

    getOfficeWBS(productId: string | undefined): Promise<FeeMatrixOfficeWBSModel[]> {
        let url_ = this.baseUrl + "/api/feematrix/offics_wbs?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetOfficeWBS(_response);
        });
    }

    protected processGetOfficeWBS(response: Response): Promise<FeeMatrixOfficeWBSModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(FeeMatrixOfficeWBSModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FeeMatrixOfficeWBSModel[]>(<any>null);
    }

    getStartDate(productId: string | undefined): Promise<Date> {
        let url_ = this.baseUrl + "/api/feematrix/start_date?";
        if (productId === null)
            throw new Error("The parameter 'productId' cannot be null.");
        else if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStartDate(_response);
        });
    }

    protected processGetStartDate(response: Response): Promise<Date> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? new Date(resultData200.toString()) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Date>(<any>null);
    }

    getById(id: string): Promise<FeeMatrixModel> {
        let url_ = this.baseUrl + "/api/feematrix/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<FeeMatrixModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FeeMatrixModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FeeMatrixModel>(<any>null);
    }

    changeStatus(model: ChangeFeeMatrixStatusModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/feematrix/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeStatus(_response);
        });
    }

    protected processChangeStatus(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getStatus(): Promise<FeeMatrixStatus[]> {
        let url_ = this.baseUrl + "/api/feematrix/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<FeeMatrixStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FeeMatrixStatus[]>(<any>null);
    }

    search(productId: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, status: FeeMatrixStatus | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfFeeMatrixModel> {
        let url_ = this.baseUrl + "/api/feematrix/search?";
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PagedResultOfFeeMatrixModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfFeeMatrixModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfFeeMatrixModel>(<any>null);
    }
}

export class GLAccountClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    getAll(): Promise<GLAccountModel[]> {
        let url_ = this.baseUrl + "/api/glaccount/getall";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<GLAccountModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GLAccountModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GLAccountModel[]>(<any>null);
    }

    modifyList(model: GLAccountModel[]): Promise<GLAccountModel[]> {
        let url_ = this.baseUrl + "/api/glaccount/modifylist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModifyList(_response);
        });
    }

    protected processModifyList(response: Response): Promise<GLAccountModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GLAccountModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GLAccountModel[]>(<any>null);
    }
}

export class JournalRecordClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    /**
     * @param inputConditions (optional) ApplicationIdAndOrderNoAndCustomer
     * @param officeId (optional) 
     * @param productId (optional) 
     * @param journalType (optional) 
     * @param completeDateTime (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorts (optional) 
     * @param filters (optional) 
     */
    search(inputConditions: string | null | undefined, officeId: string | null | undefined, productId: string | null | undefined, journalType: JournalType | null | undefined, completeDateTime: Date | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfJournalRecordModel> {
        let url_ = this.baseUrl + "/api/journalrecord/search?";
        if (inputConditions !== undefined)
            url_ += "InputConditions=" + encodeURIComponent("" + inputConditions) + "&"; 
        if (officeId !== undefined)
            url_ += "OfficeId=" + encodeURIComponent("" + officeId) + "&"; 
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&"; 
        if (journalType !== undefined)
            url_ += "JournalType=" + encodeURIComponent("" + journalType) + "&"; 
        if (completeDateTime !== undefined)
            url_ += "CompleteDateTime=" + encodeURIComponent(completeDateTime ? "" + completeDateTime.toJSON() : "") + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PagedResultOfJournalRecordModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfJournalRecordModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfJournalRecordModel>(<any>null);
    }
}

export class OfficeClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    getAll(): Promise<OfficeModel[]> {
        let url_ = this.baseUrl + "/api/office/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<OfficeModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OfficeModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OfficeModel[]>(<any>null);
    }
}

export class OrderClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    search(orderNoOrCustomer: string | null | undefined, payFromTime: Date | null | undefined, payToTime: Date | null | undefined, status: OrderStatus | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfOrderListModel> {
        let url_ = this.baseUrl + "/order/search?";
        if (orderNoOrCustomer !== undefined)
            url_ += "OrderNoOrCustomer=" + encodeURIComponent("" + orderNoOrCustomer) + "&"; 
        if (payFromTime !== undefined)
            url_ += "PayFromTime=" + encodeURIComponent(payFromTime ? "" + payFromTime.toJSON() : "") + "&"; 
        if (payToTime !== undefined)
            url_ += "PayToTime=" + encodeURIComponent(payToTime ? "" + payToTime.toJSON() : "") + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PagedResultOfOrderListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfOrderListModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfOrderListModel>(<any>null);
    }

    getById(id: string): Promise<OrderDetailModel> {
        let url_ = this.baseUrl + "/order/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<OrderDetailModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrderDetailModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OrderDetailModel>(<any>null);
    }
}

export class PaymentChannelClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    gatAll(): Promise<PaymentChannelModel[]> {
        let url_ = this.baseUrl + "/api/paymentchannel/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGatAll(_response);
        });
    }

    protected processGatAll(response: Response): Promise<PaymentChannelModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentChannelModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentChannelModel[]>(<any>null);
    }

    modifyList(model: PaymentChannelModel[]): Promise<PaymentChannelModel[]> {
        let url_ = this.baseUrl + "/api/paymentchannel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModifyList(_response);
        });
    }

    protected processModifyList(response: Response): Promise<PaymentChannelModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentChannelModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentChannelModel[]>(<any>null);
    }
}

export class ProductClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    getAll(): Promise<ProductModel[]> {
        let url_ = this.baseUrl + "/api/product/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<ProductModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductModel[]>(<any>null);
    }

    getBySessionDate(session_date: Date): Promise<ProductFeeMatrixModel[]> {
        let url_ = this.baseUrl + "/api/product/{session_date}";
        if (session_date === undefined || session_date === null)
            throw new Error("The parameter 'session_date' must be defined.");
        url_ = url_.replace("{session_date}", encodeURIComponent(session_date ? "" + session_date.toJSON() : "null")); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBySessionDate(_response);
        });
    }

    protected processGetBySessionDate(response: Response): Promise<ProductFeeMatrixModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductFeeMatrixModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ProductFeeMatrixModel[]>(<any>null);
    }
}

export class RefundClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    add(model: ApplicationRefundModel): Promise<ApplicationRefundModel> {
        let url_ = this.baseUrl + "/api/refund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<ApplicationRefundModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRefundModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRefundModel>(<any>null);
    }

    modify(model: ApplicationRefundModel): Promise<ApplicationRefundModel> {
        let url_ = this.baseUrl + "/api/refund";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModify(_response);
        });
    }

    protected processModify(response: Response): Promise<ApplicationRefundModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationRefundModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationRefundModel>(<any>null);
    }

    search(applicationId: string | null | undefined, orderNo: string | null | undefined, customer: string | null | undefined, officeId: string | null | undefined, productId: string | null | undefined, status: ApplicationRefundStatus | null | undefined, submittedStartDate: Date | null | undefined, submittedEndDate: Date | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfRefundListModel> {
        let url_ = this.baseUrl + "/api/refund/search?";
        if (applicationId !== undefined)
            url_ += "ApplicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        if (orderNo !== undefined)
            url_ += "OrderNo=" + encodeURIComponent("" + orderNo) + "&"; 
        if (customer !== undefined)
            url_ += "Customer=" + encodeURIComponent("" + customer) + "&"; 
        if (officeId !== undefined)
            url_ += "OfficeId=" + encodeURIComponent("" + officeId) + "&"; 
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (submittedStartDate !== undefined)
            url_ += "SubmittedStartDate=" + encodeURIComponent(submittedStartDate ? "" + submittedStartDate.toJSON() : "") + "&"; 
        if (submittedEndDate !== undefined)
            url_ += "SubmittedEndDate=" + encodeURIComponent(submittedEndDate ? "" + submittedEndDate.toJSON() : "") + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PagedResultOfRefundListModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfRefundListModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfRefundListModel>(<any>null);
    }

    updateStatus(model: UpdateApplicationRefundStatusModel): Promise<boolean> {
        let url_ = this.baseUrl + "/api/refund/status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    confirmRefund(applicationId: string | undefined): Promise<PaymentRefundModel> {
        let url_ = this.baseUrl + "/api/refund/confirm?";
        if (applicationId === null)
            throw new Error("The parameter 'applicationId' cannot be null.");
        else if (applicationId !== undefined)
            url_ += "applicationId=" + encodeURIComponent("" + applicationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmRefund(_response);
        });
    }

    protected processConfirmRefund(response: Response): Promise<PaymentRefundModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentRefundModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PaymentRefundModel>(<any>null);
    }

    payeaseRefundCompleted(): Promise<void> {
        let url_ = this.baseUrl + "/api/refund/completed";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPayeaseRefundCompleted(_response);
        });
    }

    protected processPayeaseRefundCompleted(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class SessionClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    add(session: SessionModel): Promise<SessionModel> {
        let url_ = this.baseUrl + "/api/session";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<SessionModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionModel>(<any>null);
    }

    modify(session: SessionModel): Promise<SessionModel> {
        let url_ = this.baseUrl + "/api/session";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(session);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModify(_response);
        });
    }

    protected processModify(response: Response): Promise<SessionModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionModel>(<any>null);
    }

    deleteById(id: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/session/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteById(_response);
        });
    }

    protected processDeleteById(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getById(id: string): Promise<SessionModel> {
        let url_ = this.baseUrl + "/api/session/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<SessionModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionModel>(<any>null);
    }

    /**
     * @param sessionId (optional) session id
     * @param cityId (optional) city id
     * @param productId (optional) product id
     * @param status (optional) status
     * @param examDate (optional) exam date
     * @param isCancellationRequest (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param sorts (optional) 
     * @param filters (optional) 
     */
    search(sessionId: string | null | undefined, cityId: string | null | undefined, productId: string | null | undefined, status: SessionStatus | null | undefined, examDate: string | null | undefined, isCancellationRequest: boolean | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfSessionModel> {
        let url_ = this.baseUrl + "/api/session/search?";
        if (sessionId !== undefined)
            url_ += "SessionId=" + encodeURIComponent("" + sessionId) + "&"; 
        if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&"; 
        if (productId !== undefined)
            url_ += "ProductId=" + encodeURIComponent("" + productId) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (examDate !== undefined)
            url_ += "ExamDate=" + encodeURIComponent("" + examDate) + "&"; 
        if (isCancellationRequest !== undefined)
            url_ += "IsCancellationRequest=" + encodeURIComponent("" + isCancellationRequest) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PagedResultOfSessionModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfSessionModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfSessionModel>(<any>null);
    }

    getStatus(): Promise<SessionStatus[]> {
        let url_ = this.baseUrl + "/api/session/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetStatus(_response);
        });
    }

    protected processGetStatus(response: Response): Promise<SessionStatus[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionStatus[]>(<any>null);
    }

    sendApplicationEmail(sessionid: string): Promise<boolean> {
        let url_ = this.baseUrl + "/api/session/sendemail/{sessionid}";
        if (sessionid === undefined || sessionid === null)
            throw new Error("The parameter 'sessionid' must be defined.");
        url_ = url_.replace("{sessionid}", encodeURIComponent("" + sessionid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSendApplicationEmail(_response);
        });
    }

    protected processSendApplicationEmail(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }

    getConfirmationLetter(sessionid: string): Promise<ResultMessageOfSessionConfirmationModel> {
        let url_ = this.baseUrl + "/api/session/confirmationletter/{sessionid}";
        if (sessionid === undefined || sessionid === null)
            throw new Error("The parameter 'sessionid' must be defined.");
        url_ = url_.replace("{sessionid}", encodeURIComponent("" + sessionid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetConfirmationLetter(_response);
        });
    }

    protected processGetConfirmationLetter(response: Response): Promise<ResultMessageOfSessionConfirmationModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultMessageOfSessionConfirmationModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultMessageOfSessionConfirmationModel>(<any>null);
    }
}

export class SubjectClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    getAll(productId: string | null | undefined, candidateType: CandidateType | null | undefined): Promise<SubjectModel[]> {
        let url_ = this.baseUrl + "/api/subject/all?";
        if (productId !== undefined)
            url_ += "productId=" + encodeURIComponent("" + productId) + "&"; 
        if (candidateType !== undefined)
            url_ += "candidateType=" + encodeURIComponent("" + candidateType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<SubjectModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubjectModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubjectModel[]>(<any>null);
    }

    getBySessionId(sessionid: string): Promise<SubjectModel[]> {
        let url_ = this.baseUrl + "/api/subject/subjects/sessionid/{sessionid}";
        if (sessionid === undefined || sessionid === null)
            throw new Error("The parameter 'sessionid' must be defined.");
        url_ = url_.replace("{sessionid}", encodeURIComponent("" + sessionid)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetBySessionId(_response);
        });
    }

    protected processGetBySessionId(response: Response): Promise<SubjectModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubjectModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubjectModel[]>(<any>null);
    }
}

export class VenueClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8810";
    }

    getAll(): Promise<VenueModel[]> {
        let url_ = this.baseUrl + "/api/venue/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<VenueModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VenueModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VenueModel[]>(<any>null);
    }

    getById(id: string): Promise<VenueModel> {
        let url_ = this.baseUrl + "/api/venue/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<VenueModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VenueModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VenueModel>(<any>null);
    }

    getByCityId(id: string): Promise<VenueModel[]> {
        let url_ = this.baseUrl + "/api/venue/city/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetByCityId(_response);
        });
    }

    protected processGetByCityId(response: Response): Promise<VenueModel[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(VenueModel.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VenueModel[]>(<any>null);
    }

    search(keyWord: string | null | undefined, officeId: string | null | undefined, cityId: string | null | undefined, status: VenueStatus | null | undefined, pageIndex: number | undefined, pageSize: number | undefined, sorts: Sort[] | null | undefined, filters: Filter[] | null | undefined): Promise<PagedResultOfVenueModel> {
        let url_ = this.baseUrl + "/api/venue/search?";
        if (keyWord !== undefined)
            url_ += "KeyWord=" + encodeURIComponent("" + keyWord) + "&"; 
        if (officeId !== undefined)
            url_ += "OfficeId=" + encodeURIComponent("" + officeId) + "&"; 
        if (cityId !== undefined)
            url_ += "CityId=" + encodeURIComponent("" + cityId) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "PageIndex=" + encodeURIComponent("" + pageIndex) + "&"; 
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&"; 
        if (sorts !== undefined)
            sorts && sorts.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Sorts[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filters !== undefined)
            filters && filters.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch(_response);
        });
    }

    protected processSearch(response: Response): Promise<PagedResultOfVenueModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultOfVenueModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PagedResultOfVenueModel>(<any>null);
    }

    add(model: VenueModel): Promise<VenueModel> {
        let url_ = this.baseUrl + "/api/venue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAdd(_response);
        });
    }

    protected processAdd(response: Response): Promise<VenueModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VenueModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VenueModel>(<any>null);
    }

    modify(model: VenueModel): Promise<VenueModel> {
        let url_ = this.baseUrl + "/api/venue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processModify(_response);
        });
    }

    protected processModify(response: Response): Promise<VenueModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VenueModel.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<VenueModel>(<any>null);
    }

    updateStatus(id: string, status: VenueStatus): Promise<boolean> {
        let url_ = this.baseUrl + "/api/venue/{id}/{status}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PUT",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateStatus(_response);
        });
    }

    protected processUpdateStatus(response: Response): Promise<boolean> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export class PagedResultOfApplicationListModel implements IPagedResultOfApplicationListModel {
    list?: ApplicationListModel[] | undefined;
    pageSize!: number;
    pageIndex!: number;
    recordCount!: number;
    pageCount!: number;

    constructor(data?: IPagedResultOfApplicationListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(ApplicationListModel.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.recordCount = _data["recordCount"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultOfApplicationListModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfApplicationListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["recordCount"] = this.recordCount;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultOfApplicationListModel {
    list?: ApplicationListModel[] | undefined;
    pageSize: number;
    pageIndex: number;
    recordCount: number;
    pageCount: number;
}

export class ApplicationListModel implements IApplicationListModel {
    id?: string | undefined;
    code?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    productName?: string | undefined;
    subjectName?: string | undefined;
    officeName?: string | undefined;
    cityName?: string | undefined;
    examDate?: Date | undefined;
    registrationDate?: Date | undefined;
    emailStatus!: ApplicationSendEmailStatus;
    status?: ApplicationStatus | undefined;
    payment?: number | undefined;
    applicationRefund?: ApplicationRefundModel | undefined;

    constructor(data?: IApplicationListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.productName = _data["productName"];
            this.subjectName = _data["subjectName"];
            this.officeName = _data["officeName"];
            this.cityName = _data["cityName"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.registrationDate = _data["registrationDate"] ? new Date(_data["registrationDate"].toString()) : <any>undefined;
            this.emailStatus = _data["emailStatus"];
            this.status = _data["status"];
            this.payment = _data["payment"];
            this.applicationRefund = _data["applicationRefund"] ? ApplicationRefundModel.fromJS(_data["applicationRefund"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationListModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["productName"] = this.productName;
        data["subjectName"] = this.subjectName;
        data["officeName"] = this.officeName;
        data["cityName"] = this.cityName;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["registrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
        data["emailStatus"] = this.emailStatus;
        data["status"] = this.status;
        data["payment"] = this.payment;
        data["applicationRefund"] = this.applicationRefund ? this.applicationRefund.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApplicationListModel {
    id?: string | undefined;
    code?: number | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    productName?: string | undefined;
    subjectName?: string | undefined;
    officeName?: string | undefined;
    cityName?: string | undefined;
    examDate?: Date | undefined;
    registrationDate?: Date | undefined;
    emailStatus: ApplicationSendEmailStatus;
    status?: ApplicationStatus | undefined;
    payment?: number | undefined;
    applicationRefund?: ApplicationRefundModel | undefined;
}

export enum ApplicationSendEmailStatus {
    NotSent = "NotSent",
    Sending = "Sending",
    Success = "Success",
    Failed = "Failed",
}

export enum ApplicationStatus {
    Submited = "Submited",
    Registered = "Registered",
    Withdrawn = "Withdrawn",
    RegisteredCancellationRequested = "RegisteredCancellationRequested",
    RegisteredCancellationRejected = "RegisteredCancellationRejected",
    Cancelled = "Cancelled",
    Expired = "Expired",
}

export class ApplicationRefundModel implements IApplicationRefundModel {
    id?: string | undefined;
    localFeeAmount!: number;
    boardFeeAmount!: number;
    vat!: number;
    totalAmount!: number;
    status!: ApplicationRefundStatus;
    refundReason?: string | undefined;
    code?: string | undefined;
    serialNumber?: string | undefined;
    refundTime?: Date | undefined;
    applicationId!: string;

    constructor(data?: IApplicationRefundModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localFeeAmount = _data["localFeeAmount"];
            this.boardFeeAmount = _data["boardFeeAmount"];
            this.vat = _data["vat"];
            this.totalAmount = _data["totalAmount"];
            this.status = _data["status"];
            this.refundReason = _data["refundReason"];
            this.code = _data["code"];
            this.serialNumber = _data["serialNumber"];
            this.refundTime = _data["refundTime"] ? new Date(_data["refundTime"].toString()) : <any>undefined;
            this.applicationId = _data["applicationId"];
        }
    }

    static fromJS(data: any): ApplicationRefundModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationRefundModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localFeeAmount"] = this.localFeeAmount;
        data["boardFeeAmount"] = this.boardFeeAmount;
        data["vat"] = this.vat;
        data["totalAmount"] = this.totalAmount;
        data["status"] = this.status;
        data["refundReason"] = this.refundReason;
        data["code"] = this.code;
        data["serialNumber"] = this.serialNumber;
        data["refundTime"] = this.refundTime ? this.refundTime.toISOString() : <any>undefined;
        data["applicationId"] = this.applicationId;
        return data; 
    }
}

export interface IApplicationRefundModel {
    id?: string | undefined;
    localFeeAmount: number;
    boardFeeAmount: number;
    vat: number;
    totalAmount: number;
    status: ApplicationRefundStatus;
    refundReason?: string | undefined;
    code?: string | undefined;
    serialNumber?: string | undefined;
    refundTime?: Date | undefined;
    applicationId: string;
}

export enum ApplicationRefundStatus {
    Drafted = "Drafted",
    Submitted = "Submitted",
    Approved = "Approved",
}

export class Sort implements ISort {
    field?: string | undefined;
    desc!: boolean;

    constructor(data?: ISort) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.desc = _data["desc"];
        }
    }

    static fromJS(data: any): Sort {
        data = typeof data === 'object' ? data : {};
        let result = new Sort();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["desc"] = this.desc;
        return data; 
    }
}

export interface ISort {
    field?: string | undefined;
    desc: boolean;
}

export class Filter implements IFilter {
    field?: string | undefined;
    value?: any | undefined;

    constructor(data?: IFilter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): Filter {
        data = typeof data === 'object' ? data : {};
        let result = new Filter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["value"] = this.value;
        return data; 
    }
}

export interface IFilter {
    field?: string | undefined;
    value?: any | undefined;
}

export class ApplicationModel implements IApplicationModel {
    id?: string | undefined;
    code!: number;
    emailStatus!: ApplicationSendEmailStatus;
    leaveAlone!: boolean;
    withdrawReason?: string | undefined;
    cancellationRequestReason?: string | undefined;
    cancellationRejectReason?: string | undefined;
    registrationDate?: Date | undefined;
    status!: ApplicationStatus;
    payment!: number;
    amount!: number;
    session?: SessionModel | undefined;
    subject?: SubjectModel | undefined;
    applicationCandidate?: ApplicationCandidateModel | undefined;
    applicationGuardian?: ApplicationGuardianModel | undefined;
    applicationPickupPerson?: ApplicationPickupPersonModel | undefined;
    applicationSteps?: ApplicationStepModel[] | undefined;
    user?: UserModel | undefined;

    constructor(data?: IApplicationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.emailStatus = _data["emailStatus"];
            this.leaveAlone = _data["leaveAlone"];
            this.withdrawReason = _data["withdrawReason"];
            this.cancellationRequestReason = _data["cancellationRequestReason"];
            this.cancellationRejectReason = _data["cancellationRejectReason"];
            this.registrationDate = _data["registrationDate"] ? new Date(_data["registrationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.payment = _data["payment"];
            this.amount = _data["amount"];
            this.session = _data["session"] ? SessionModel.fromJS(_data["session"]) : <any>undefined;
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.applicationCandidate = _data["applicationCandidate"] ? ApplicationCandidateModel.fromJS(_data["applicationCandidate"]) : <any>undefined;
            this.applicationGuardian = _data["applicationGuardian"] ? ApplicationGuardianModel.fromJS(_data["applicationGuardian"]) : <any>undefined;
            this.applicationPickupPerson = _data["applicationPickupPerson"] ? ApplicationPickupPersonModel.fromJS(_data["applicationPickupPerson"]) : <any>undefined;
            if (Array.isArray(_data["applicationSteps"])) {
                this.applicationSteps = [] as any;
                for (let item of _data["applicationSteps"])
                    this.applicationSteps!.push(ApplicationStepModel.fromJS(item));
            }
            this.user = _data["user"] ? UserModel.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["emailStatus"] = this.emailStatus;
        data["leaveAlone"] = this.leaveAlone;
        data["withdrawReason"] = this.withdrawReason;
        data["cancellationRequestReason"] = this.cancellationRequestReason;
        data["cancellationRejectReason"] = this.cancellationRejectReason;
        data["registrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["payment"] = this.payment;
        data["amount"] = this.amount;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["applicationCandidate"] = this.applicationCandidate ? this.applicationCandidate.toJSON() : <any>undefined;
        data["applicationGuardian"] = this.applicationGuardian ? this.applicationGuardian.toJSON() : <any>undefined;
        data["applicationPickupPerson"] = this.applicationPickupPerson ? this.applicationPickupPerson.toJSON() : <any>undefined;
        if (Array.isArray(this.applicationSteps)) {
            data["applicationSteps"] = [];
            for (let item of this.applicationSteps)
                data["applicationSteps"].push(item.toJSON());
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApplicationModel {
    id?: string | undefined;
    code: number;
    emailStatus: ApplicationSendEmailStatus;
    leaveAlone: boolean;
    withdrawReason?: string | undefined;
    cancellationRequestReason?: string | undefined;
    cancellationRejectReason?: string | undefined;
    registrationDate?: Date | undefined;
    status: ApplicationStatus;
    payment: number;
    amount: number;
    session?: SessionModel | undefined;
    subject?: SubjectModel | undefined;
    applicationCandidate?: ApplicationCandidateModel | undefined;
    applicationGuardian?: ApplicationGuardianModel | undefined;
    applicationPickupPerson?: ApplicationPickupPersonModel | undefined;
    applicationSteps?: ApplicationStepModel[] | undefined;
    user?: UserModel | undefined;
}

export class SessionModel implements ISessionModel {
    id?: string | undefined;
    product?: ProductModel | undefined;
    officeName?: string | undefined;
    examDate!: Date;
    startTime!: string;
    endTime!: string;
    seat!: number;
    registered!: number;
    publishStartTime!: Date;
    publishEndTime!: Date;
    canSend!: boolean;
    isExclusiveSession!: boolean;
    pin?: string | undefined;
    notice?: string | undefined;
    createBy?: string | undefined;
    status!: SessionStatus;
    isSendEmail!: boolean;
    venue?: VenueModel | undefined;
    city?: CityModel | undefined;
    sessionSubjects?: SessionSubjectModel[] | undefined;
    sessionLateEntryCharges?: SessionLateEntryChargeModel[] | undefined;

    constructor(data?: ISessionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.product = _data["product"] ? ProductModel.fromJS(_data["product"]) : <any>undefined;
            this.officeName = _data["officeName"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.startTime = _data["startTime"];
            this.endTime = _data["endTime"];
            this.seat = _data["seat"];
            this.registered = _data["registered"];
            this.publishStartTime = _data["publishStartTime"] ? new Date(_data["publishStartTime"].toString()) : <any>undefined;
            this.publishEndTime = _data["publishEndTime"] ? new Date(_data["publishEndTime"].toString()) : <any>undefined;
            this.canSend = _data["canSend"];
            this.isExclusiveSession = _data["isExclusiveSession"];
            this.pin = _data["pin"];
            this.notice = _data["notice"];
            this.createBy = _data["createBy"];
            this.status = _data["status"];
            this.isSendEmail = _data["isSendEmail"];
            this.venue = _data["venue"] ? VenueModel.fromJS(_data["venue"]) : <any>undefined;
            this.city = _data["city"] ? CityModel.fromJS(_data["city"]) : <any>undefined;
            if (Array.isArray(_data["sessionSubjects"])) {
                this.sessionSubjects = [] as any;
                for (let item of _data["sessionSubjects"])
                    this.sessionSubjects!.push(SessionSubjectModel.fromJS(item));
            }
            if (Array.isArray(_data["sessionLateEntryCharges"])) {
                this.sessionLateEntryCharges = [] as any;
                for (let item of _data["sessionLateEntryCharges"])
                    this.sessionLateEntryCharges!.push(SessionLateEntryChargeModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SessionModel {
        data = typeof data === 'object' ? data : {};
        let result = new SessionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["officeName"] = this.officeName;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["startTime"] = this.startTime;
        data["endTime"] = this.endTime;
        data["seat"] = this.seat;
        data["registered"] = this.registered;
        data["publishStartTime"] = this.publishStartTime ? this.publishStartTime.toISOString() : <any>undefined;
        data["publishEndTime"] = this.publishEndTime ? this.publishEndTime.toISOString() : <any>undefined;
        data["canSend"] = this.canSend;
        data["isExclusiveSession"] = this.isExclusiveSession;
        data["pin"] = this.pin;
        data["notice"] = this.notice;
        data["createBy"] = this.createBy;
        data["status"] = this.status;
        data["isSendEmail"] = this.isSendEmail;
        data["venue"] = this.venue ? this.venue.toJSON() : <any>undefined;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        if (Array.isArray(this.sessionSubjects)) {
            data["sessionSubjects"] = [];
            for (let item of this.sessionSubjects)
                data["sessionSubjects"].push(item.toJSON());
        }
        if (Array.isArray(this.sessionLateEntryCharges)) {
            data["sessionLateEntryCharges"] = [];
            for (let item of this.sessionLateEntryCharges)
                data["sessionLateEntryCharges"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISessionModel {
    id?: string | undefined;
    product?: ProductModel | undefined;
    officeName?: string | undefined;
    examDate: Date;
    startTime: string;
    endTime: string;
    seat: number;
    registered: number;
    publishStartTime: Date;
    publishEndTime: Date;
    canSend: boolean;
    isExclusiveSession: boolean;
    pin?: string | undefined;
    notice?: string | undefined;
    createBy?: string | undefined;
    status: SessionStatus;
    isSendEmail: boolean;
    venue?: VenueModel | undefined;
    city?: CityModel | undefined;
    sessionSubjects?: SessionSubjectModel[] | undefined;
    sessionLateEntryCharges?: SessionLateEntryChargeModel[] | undefined;
}

export class ProductModel implements IProductModel {
    id!: string;
    productName?: string | undefined;
    code?: string | undefined;
    awardingBodyId!: string;
    awardingBodyName?: string | undefined;
    createBy?: string | undefined;
    productOfficeWBS?: ProductOfficeModel[] | undefined;
    subjects?: SubjectModel[] | undefined;

    constructor(data?: IProductModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.code = _data["code"];
            this.awardingBodyId = _data["awardingBodyId"];
            this.awardingBodyName = _data["awardingBodyName"];
            this.createBy = _data["createBy"];
            if (Array.isArray(_data["productOfficeWBS"])) {
                this.productOfficeWBS = [] as any;
                for (let item of _data["productOfficeWBS"])
                    this.productOfficeWBS!.push(ProductOfficeModel.fromJS(item));
            }
            if (Array.isArray(_data["subjects"])) {
                this.subjects = [] as any;
                for (let item of _data["subjects"])
                    this.subjects!.push(SubjectModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["code"] = this.code;
        data["awardingBodyId"] = this.awardingBodyId;
        data["awardingBodyName"] = this.awardingBodyName;
        data["createBy"] = this.createBy;
        if (Array.isArray(this.productOfficeWBS)) {
            data["productOfficeWBS"] = [];
            for (let item of this.productOfficeWBS)
                data["productOfficeWBS"].push(item.toJSON());
        }
        if (Array.isArray(this.subjects)) {
            data["subjects"] = [];
            for (let item of this.subjects)
                data["subjects"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IProductModel {
    id: string;
    productName?: string | undefined;
    code?: string | undefined;
    awardingBodyId: string;
    awardingBodyName?: string | undefined;
    createBy?: string | undefined;
    productOfficeWBS?: ProductOfficeModel[] | undefined;
    subjects?: SubjectModel[] | undefined;
}

export class ProductOfficeModel implements IProductOfficeModel {
    id!: string;
    officeId!: string;
    wbs?: string | undefined;

    constructor(data?: IProductOfficeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.officeId = _data["officeId"];
            this.wbs = _data["wbs"];
        }
    }

    static fromJS(data: any): ProductOfficeModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOfficeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["officeId"] = this.officeId;
        data["wbs"] = this.wbs;
        return data; 
    }
}

export interface IProductOfficeModel {
    id: string;
    officeId: string;
    wbs?: string | undefined;
}

export class SubjectModel implements ISubjectModel {
    id?: string | undefined;
    subjectName?: string | undefined;
    sort!: number;

    constructor(data?: ISubjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectName = _data["subjectName"];
            this.sort = _data["sort"];
        }
    }

    static fromJS(data: any): SubjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SubjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectName"] = this.subjectName;
        data["sort"] = this.sort;
        return data; 
    }
}

export interface ISubjectModel {
    id?: string | undefined;
    subjectName?: string | undefined;
    sort: number;
}

export enum SessionStatus {
    NotStarted = "NotStarted",
    Available = "Available",
    Full = "Full",
    RegistrationEnded = "RegistrationEnded",
    Expire = "Expire",
}

export class VenueModel implements IVenueModel {
    id?: string | undefined;
    code!: number;
    name?: string | undefined;
    status!: VenueStatus;
    city?: CityModel | undefined;
    address?: string | undefined;
    multiLanguages?: MultiLanguageModel[] | undefined;

    constructor(data?: IVenueModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.name = _data["name"];
            this.status = _data["status"];
            this.city = _data["city"] ? CityModel.fromJS(_data["city"]) : <any>undefined;
            this.address = _data["address"];
            if (Array.isArray(_data["multiLanguages"])) {
                this.multiLanguages = [] as any;
                for (let item of _data["multiLanguages"])
                    this.multiLanguages!.push(MultiLanguageModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): VenueModel {
        data = typeof data === 'object' ? data : {};
        let result = new VenueModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["name"] = this.name;
        data["status"] = this.status;
        data["city"] = this.city ? this.city.toJSON() : <any>undefined;
        data["address"] = this.address;
        if (Array.isArray(this.multiLanguages)) {
            data["multiLanguages"] = [];
            for (let item of this.multiLanguages)
                data["multiLanguages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IVenueModel {
    id?: string | undefined;
    code: number;
    name?: string | undefined;
    status: VenueStatus;
    city?: CityModel | undefined;
    address?: string | undefined;
    multiLanguages?: MultiLanguageModel[] | undefined;
}

export enum VenueStatus {
    Inacitive = "Inacitive",
    Active = "Active",
}

export class CityModel implements ICityModel {
    office?: OfficeModel | undefined;
    id!: string;
    name?: string | undefined;

    constructor(data?: ICityModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.office = _data["office"] ? OfficeModel.fromJS(_data["office"]) : <any>undefined;
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CityModel {
        data = typeof data === 'object' ? data : {};
        let result = new CityModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["office"] = this.office ? this.office.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICityModel {
    office?: OfficeModel | undefined;
    id: string;
    name?: string | undefined;
}

export class OfficeModel implements IOfficeModel {
    id!: string;
    name?: string | undefined;
    sortNum!: number;

    constructor(data?: IOfficeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.sortNum = _data["sortNum"];
        }
    }

    static fromJS(data: any): OfficeModel {
        data = typeof data === 'object' ? data : {};
        let result = new OfficeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["sortNum"] = this.sortNum;
        return data; 
    }
}

export interface IOfficeModel {
    id: string;
    name?: string | undefined;
    sortNum: number;
}

export class MultiLanguageModel implements IMultiLanguageModel {
    id?: string | undefined;
    code?: string | undefined;
    languageType!: LanguageType;
    displayName?: string | undefined;

    constructor(data?: IMultiLanguageModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.languageType = _data["languageType"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MultiLanguageModel {
        data = typeof data === 'object' ? data : {};
        let result = new MultiLanguageModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["languageType"] = this.languageType;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IMultiLanguageModel {
    id?: string | undefined;
    code?: string | undefined;
    languageType: LanguageType;
    displayName?: string | undefined;
}

export enum LanguageType {
    En = "En",
    Zh = "Zh",
}

export class SessionSubjectModel implements ISessionSubjectModel {
    id!: string;
    subjectId!: string;
    subject?: SubjectModel | undefined;
    localFee!: number;
    boardFee!: number;
    total!: number;
    isTier!: boolean;
    isLateEntryCharge!: boolean;
    sessionSubjectTierFees?: SessionSubjectTierFeeModel[] | undefined;

    constructor(data?: ISessionSubjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subjectId = _data["subjectId"];
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.localFee = _data["localFee"];
            this.boardFee = _data["boardFee"];
            this.total = _data["total"];
            this.isTier = _data["isTier"];
            this.isLateEntryCharge = _data["isLateEntryCharge"];
            if (Array.isArray(_data["sessionSubjectTierFees"])) {
                this.sessionSubjectTierFees = [] as any;
                for (let item of _data["sessionSubjectTierFees"])
                    this.sessionSubjectTierFees!.push(SessionSubjectTierFeeModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SessionSubjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new SessionSubjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subjectId"] = this.subjectId;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["localFee"] = this.localFee;
        data["boardFee"] = this.boardFee;
        data["total"] = this.total;
        data["isTier"] = this.isTier;
        data["isLateEntryCharge"] = this.isLateEntryCharge;
        if (Array.isArray(this.sessionSubjectTierFees)) {
            data["sessionSubjectTierFees"] = [];
            for (let item of this.sessionSubjectTierFees)
                data["sessionSubjectTierFees"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISessionSubjectModel {
    id: string;
    subjectId: string;
    subject?: SubjectModel | undefined;
    localFee: number;
    boardFee: number;
    total: number;
    isTier: boolean;
    isLateEntryCharge: boolean;
    sessionSubjectTierFees?: SessionSubjectTierFeeModel[] | undefined;
}

export class SessionSubjectTierFeeModel implements ISessionSubjectTierFeeModel {
    id?: string | undefined;
    from!: number;
    to!: number;
    localFee!: number;

    constructor(data?: ISessionSubjectTierFeeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.localFee = _data["localFee"];
        }
    }

    static fromJS(data: any): SessionSubjectTierFeeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SessionSubjectTierFeeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["from"] = this.from;
        data["to"] = this.to;
        data["localFee"] = this.localFee;
        return data; 
    }
}

export interface ISessionSubjectTierFeeModel {
    id?: string | undefined;
    from: number;
    to: number;
    localFee: number;
}

export class SessionLateEntryChargeModel implements ISessionLateEntryChargeModel {
    id!: string;
    stage!: number;
    fee!: number;
    startDate!: Date;
    endDate!: Date;

    constructor(data?: ISessionLateEntryChargeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stage = _data["stage"];
            this.fee = _data["fee"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SessionLateEntryChargeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SessionLateEntryChargeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stage"] = this.stage;
        data["fee"] = this.fee;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ISessionLateEntryChargeModel {
    id: string;
    stage: number;
    fee: number;
    startDate: Date;
    endDate: Date;
}

export class ApplicationCandidateModel implements IApplicationCandidateModel {
    id?: string | undefined;
    idType!: IDType;
    gender!: Gender;
    firstName?: string | undefined;
    lastName?: string | undefined;
    idNo?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    dob?: string | undefined;
    candidateId!: string;

    constructor(data?: IApplicationCandidateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idType = _data["idType"];
            this.gender = _data["gender"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.idNo = _data["idNo"];
            this.email = _data["email"];
            this.mobile = _data["mobile"];
            this.dob = _data["dob"];
            this.candidateId = _data["candidateId"];
        }
    }

    static fromJS(data: any): ApplicationCandidateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationCandidateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idType"] = this.idType;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["idNo"] = this.idNo;
        data["email"] = this.email;
        data["mobile"] = this.mobile;
        data["dob"] = this.dob;
        data["candidateId"] = this.candidateId;
        return data; 
    }
}

export interface IApplicationCandidateModel {
    id?: string | undefined;
    idType: IDType;
    gender: Gender;
    firstName?: string | undefined;
    lastName?: string | undefined;
    idNo?: string | undefined;
    email?: string | undefined;
    mobile?: string | undefined;
    dob?: string | undefined;
    candidateId: string;
}

export enum IDType {
    IDCard = "IDCard",
    Passport = "Passport",
    Others = "Others",
}

export enum Gender {
    Male = "Male",
    Female = "Female",
}

export class ApplicationGuardianModel implements IApplicationGuardianModel {
    id?: string | undefined;
    idType!: IDType;
    name?: string | undefined;
    idNo?: string | undefined;
    mobile?: string | undefined;

    constructor(data?: IApplicationGuardianModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idType = _data["idType"];
            this.name = _data["name"];
            this.idNo = _data["idNo"];
            this.mobile = _data["mobile"];
        }
    }

    static fromJS(data: any): ApplicationGuardianModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationGuardianModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idType"] = this.idType;
        data["name"] = this.name;
        data["idNo"] = this.idNo;
        data["mobile"] = this.mobile;
        return data; 
    }
}

export interface IApplicationGuardianModel {
    id?: string | undefined;
    idType: IDType;
    name?: string | undefined;
    idNo?: string | undefined;
    mobile?: string | undefined;
}

export class ApplicationPickupPersonModel implements IApplicationPickupPersonModel {
    id?: string | undefined;
    idType!: IDType;
    name?: string | undefined;
    idNo?: string | undefined;
    mobile?: string | undefined;

    constructor(data?: IApplicationPickupPersonModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.idType = _data["idType"];
            this.name = _data["name"];
            this.idNo = _data["idNo"];
            this.mobile = _data["mobile"];
        }
    }

    static fromJS(data: any): ApplicationPickupPersonModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPickupPersonModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["idType"] = this.idType;
        data["name"] = this.name;
        data["idNo"] = this.idNo;
        data["mobile"] = this.mobile;
        return data; 
    }
}

export interface IApplicationPickupPersonModel {
    id?: string | undefined;
    idType: IDType;
    name?: string | undefined;
    idNo?: string | undefined;
    mobile?: string | undefined;
}

export class ApplicationStepModel implements IApplicationStepModel {
    id!: string;
    applicationId?: string | undefined;
    stepName?: string | undefined;
    jsonResult?: string | undefined;

    constructor(data?: IApplicationStepModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationId = _data["applicationId"];
            this.stepName = _data["stepName"];
            this.jsonResult = _data["jsonResult"];
        }
    }

    static fromJS(data: any): ApplicationStepModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationStepModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationId"] = this.applicationId;
        data["stepName"] = this.stepName;
        data["jsonResult"] = this.jsonResult;
        return data; 
    }
}

export interface IApplicationStepModel {
    id: string;
    applicationId?: string | undefined;
    stepName?: string | undefined;
    jsonResult?: string | undefined;
}

export class UserModel implements IUserModel {
    phoneNumber?: string | undefined;
    email?: string | undefined;
    promoteStatus!: boolean;
    phoneReceivingStatus!: boolean;
    emailReceivingStatus!: boolean;
    sendMessageLanguageType!: SendMessageLanguageType;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.promoteStatus = _data["promoteStatus"];
            this.phoneReceivingStatus = _data["phoneReceivingStatus"];
            this.emailReceivingStatus = _data["emailReceivingStatus"];
            this.sendMessageLanguageType = _data["sendMessageLanguageType"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["promoteStatus"] = this.promoteStatus;
        data["phoneReceivingStatus"] = this.phoneReceivingStatus;
        data["emailReceivingStatus"] = this.emailReceivingStatus;
        data["sendMessageLanguageType"] = this.sendMessageLanguageType;
        return data; 
    }
}

export interface IUserModel {
    phoneNumber?: string | undefined;
    email?: string | undefined;
    promoteStatus: boolean;
    phoneReceivingStatus: boolean;
    emailReceivingStatus: boolean;
    sendMessageLanguageType: SendMessageLanguageType;
}

export enum SendMessageLanguageType {
    English = "English",
    Chinese = "Chinese",
}

export class ApplicationDetailModel implements IApplicationDetailModel {
    id?: string | undefined;
    code!: number;
    emailStatus!: ApplicationSendEmailStatus;
    leaveAlone!: boolean;
    withdrawReason?: string | undefined;
    cancellationRequestReason?: string | undefined;
    cancellationRejectReason?: string | undefined;
    registrationDate?: Date | undefined;
    status!: ApplicationStatus;
    payment!: number;
    amount!: number;
    session?: SessionModel | undefined;
    subject?: SubjectModel | undefined;
    orderItem?: OrderItemModel | undefined;
    applicationRefund?: ApplicationRefundModel | undefined;
    applicationCandidate?: ApplicationCandidateModel | undefined;
    applicationGuardian?: ApplicationGuardianModel | undefined;
    applicationPickupPerson?: ApplicationPickupPersonModel | undefined;
    applicationSteps?: ApplicationStepModel[] | undefined;

    constructor(data?: IApplicationDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.code = _data["code"];
            this.emailStatus = _data["emailStatus"];
            this.leaveAlone = _data["leaveAlone"];
            this.withdrawReason = _data["withdrawReason"];
            this.cancellationRequestReason = _data["cancellationRequestReason"];
            this.cancellationRejectReason = _data["cancellationRejectReason"];
            this.registrationDate = _data["registrationDate"] ? new Date(_data["registrationDate"].toString()) : <any>undefined;
            this.status = _data["status"];
            this.payment = _data["payment"];
            this.amount = _data["amount"];
            this.session = _data["session"] ? SessionModel.fromJS(_data["session"]) : <any>undefined;
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.orderItem = _data["orderItem"] ? OrderItemModel.fromJS(_data["orderItem"]) : <any>undefined;
            this.applicationRefund = _data["applicationRefund"] ? ApplicationRefundModel.fromJS(_data["applicationRefund"]) : <any>undefined;
            this.applicationCandidate = _data["applicationCandidate"] ? ApplicationCandidateModel.fromJS(_data["applicationCandidate"]) : <any>undefined;
            this.applicationGuardian = _data["applicationGuardian"] ? ApplicationGuardianModel.fromJS(_data["applicationGuardian"]) : <any>undefined;
            this.applicationPickupPerson = _data["applicationPickupPerson"] ? ApplicationPickupPersonModel.fromJS(_data["applicationPickupPerson"]) : <any>undefined;
            if (Array.isArray(_data["applicationSteps"])) {
                this.applicationSteps = [] as any;
                for (let item of _data["applicationSteps"])
                    this.applicationSteps!.push(ApplicationStepModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ApplicationDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["code"] = this.code;
        data["emailStatus"] = this.emailStatus;
        data["leaveAlone"] = this.leaveAlone;
        data["withdrawReason"] = this.withdrawReason;
        data["cancellationRequestReason"] = this.cancellationRequestReason;
        data["cancellationRejectReason"] = this.cancellationRejectReason;
        data["registrationDate"] = this.registrationDate ? this.registrationDate.toISOString() : <any>undefined;
        data["status"] = this.status;
        data["payment"] = this.payment;
        data["amount"] = this.amount;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["orderItem"] = this.orderItem ? this.orderItem.toJSON() : <any>undefined;
        data["applicationRefund"] = this.applicationRefund ? this.applicationRefund.toJSON() : <any>undefined;
        data["applicationCandidate"] = this.applicationCandidate ? this.applicationCandidate.toJSON() : <any>undefined;
        data["applicationGuardian"] = this.applicationGuardian ? this.applicationGuardian.toJSON() : <any>undefined;
        data["applicationPickupPerson"] = this.applicationPickupPerson ? this.applicationPickupPerson.toJSON() : <any>undefined;
        if (Array.isArray(this.applicationSteps)) {
            data["applicationSteps"] = [];
            for (let item of this.applicationSteps)
                data["applicationSteps"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IApplicationDetailModel {
    id?: string | undefined;
    code: number;
    emailStatus: ApplicationSendEmailStatus;
    leaveAlone: boolean;
    withdrawReason?: string | undefined;
    cancellationRequestReason?: string | undefined;
    cancellationRejectReason?: string | undefined;
    registrationDate?: Date | undefined;
    status: ApplicationStatus;
    payment: number;
    amount: number;
    session?: SessionModel | undefined;
    subject?: SubjectModel | undefined;
    orderItem?: OrderItemModel | undefined;
    applicationRefund?: ApplicationRefundModel | undefined;
    applicationCandidate?: ApplicationCandidateModel | undefined;
    applicationGuardian?: ApplicationGuardianModel | undefined;
    applicationPickupPerson?: ApplicationPickupPersonModel | undefined;
    applicationSteps?: ApplicationStepModel[] | undefined;
}

export class OrderItemModel implements IOrderItemModel {
    id!: string;
    lateEntryChargeAmount?: number | undefined;
    localFeeAmount!: number;
    boardFeeAmount!: number;
    vat!: number;
    tierCount?: number | undefined;
    tierDiscountAmount?: number | undefined;
    totalAmount!: number;
    applicationId!: string;
    application?: ApplicationModel | undefined;
    originalAmount!: number;

    constructor(data?: IOrderItemModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lateEntryChargeAmount = _data["lateEntryChargeAmount"];
            this.localFeeAmount = _data["localFeeAmount"];
            this.boardFeeAmount = _data["boardFeeAmount"];
            this.vat = _data["vat"];
            this.tierCount = _data["tierCount"];
            this.tierDiscountAmount = _data["tierDiscountAmount"];
            this.totalAmount = _data["totalAmount"];
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? ApplicationModel.fromJS(_data["application"]) : <any>undefined;
            this.originalAmount = _data["originalAmount"];
        }
    }

    static fromJS(data: any): OrderItemModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderItemModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lateEntryChargeAmount"] = this.lateEntryChargeAmount;
        data["localFeeAmount"] = this.localFeeAmount;
        data["boardFeeAmount"] = this.boardFeeAmount;
        data["vat"] = this.vat;
        data["tierCount"] = this.tierCount;
        data["tierDiscountAmount"] = this.tierDiscountAmount;
        data["totalAmount"] = this.totalAmount;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["originalAmount"] = this.originalAmount;
        return data; 
    }
}

export interface IOrderItemModel {
    id: string;
    lateEntryChargeAmount?: number | undefined;
    localFeeAmount: number;
    boardFeeAmount: number;
    vat: number;
    tierCount?: number | undefined;
    tierDiscountAmount?: number | undefined;
    totalAmount: number;
    applicationId: string;
    application?: ApplicationModel | undefined;
    originalAmount: number;
}

export class UpdateApplicationStatusModel implements IUpdateApplicationStatusModel {
    id?: string | undefined;
    reason?: string | undefined;
    status!: ApplicationStatus;

    constructor(data?: IUpdateApplicationStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reason = _data["reason"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateApplicationStatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationStatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reason"] = this.reason;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateApplicationStatusModel {
    id?: string | undefined;
    reason?: string | undefined;
    status: ApplicationStatus;
}

export class AdminUserModel implements IAdminUserModel {
    id!: string;
    role!: AdminRoleType;
    userName?: string | undefined;
    password?: string | undefined;
    token?: string | undefined;
    tokenType?: string | undefined;
    expires!: Date;
    data?: any | undefined;

    constructor(data?: IAdminUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.role = _data["role"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.token = _data["token"];
            this.tokenType = _data["tokenType"];
            this.expires = _data["expires"] ? new Date(_data["expires"].toString()) : <any>undefined;
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): AdminUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new AdminUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["role"] = this.role;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["token"] = this.token;
        data["tokenType"] = this.tokenType;
        data["expires"] = this.expires ? this.expires.toISOString() : <any>undefined;
        data["data"] = this.data;
        return data; 
    }
}

export interface IAdminUserModel {
    id: string;
    role: AdminRoleType;
    userName?: string | undefined;
    password?: string | undefined;
    token?: string | undefined;
    tokenType?: string | undefined;
    expires: Date;
    data?: any | undefined;
}

export enum AdminRoleType {
    Staff = "Staff",
    Manager = "Manager",
    Admin = "Admin",
}

export enum LoginType {
    VerificationCode = "VerificationCode",
    Password = "Password",
}

export class FeeMatrixModel implements IFeeMatrixModel {
    id?: string | undefined;
    startDate!: Date;
    endDate!: Date;
    isLateEntryCharge!: boolean;
    feeMatrixStatus!: FeeMatrixStatus;
    code?: string | undefined;
    rejectReason?: string | undefined;
    productId!: string;
    product?: ProductModel | undefined;
    feeMatrixOfficeWBSs?: FeeMatrixOfficeWBSModel[] | undefined;
    feeMatrixLateEntryCharges?: FeeMatrixLateEntryChargeModel[] | undefined;
    feeMatrixSubjects?: FeeMatrixSubjectModel[] | undefined;
    feeMatrixChanges?: FeeMatrixChangeModel[] | undefined;

    constructor(data?: IFeeMatrixModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.isLateEntryCharge = _data["isLateEntryCharge"];
            this.feeMatrixStatus = _data["feeMatrixStatus"];
            this.code = _data["code"];
            this.rejectReason = _data["rejectReason"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? ProductModel.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["feeMatrixOfficeWBSs"])) {
                this.feeMatrixOfficeWBSs = [] as any;
                for (let item of _data["feeMatrixOfficeWBSs"])
                    this.feeMatrixOfficeWBSs!.push(FeeMatrixOfficeWBSModel.fromJS(item));
            }
            if (Array.isArray(_data["feeMatrixLateEntryCharges"])) {
                this.feeMatrixLateEntryCharges = [] as any;
                for (let item of _data["feeMatrixLateEntryCharges"])
                    this.feeMatrixLateEntryCharges!.push(FeeMatrixLateEntryChargeModel.fromJS(item));
            }
            if (Array.isArray(_data["feeMatrixSubjects"])) {
                this.feeMatrixSubjects = [] as any;
                for (let item of _data["feeMatrixSubjects"])
                    this.feeMatrixSubjects!.push(FeeMatrixSubjectModel.fromJS(item));
            }
            if (Array.isArray(_data["feeMatrixChanges"])) {
                this.feeMatrixChanges = [] as any;
                for (let item of _data["feeMatrixChanges"])
                    this.feeMatrixChanges!.push(FeeMatrixChangeModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeeMatrixModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeeMatrixModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isLateEntryCharge"] = this.isLateEntryCharge;
        data["feeMatrixStatus"] = this.feeMatrixStatus;
        data["code"] = this.code;
        data["rejectReason"] = this.rejectReason;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.feeMatrixOfficeWBSs)) {
            data["feeMatrixOfficeWBSs"] = [];
            for (let item of this.feeMatrixOfficeWBSs)
                data["feeMatrixOfficeWBSs"].push(item.toJSON());
        }
        if (Array.isArray(this.feeMatrixLateEntryCharges)) {
            data["feeMatrixLateEntryCharges"] = [];
            for (let item of this.feeMatrixLateEntryCharges)
                data["feeMatrixLateEntryCharges"].push(item.toJSON());
        }
        if (Array.isArray(this.feeMatrixSubjects)) {
            data["feeMatrixSubjects"] = [];
            for (let item of this.feeMatrixSubjects)
                data["feeMatrixSubjects"].push(item.toJSON());
        }
        if (Array.isArray(this.feeMatrixChanges)) {
            data["feeMatrixChanges"] = [];
            for (let item of this.feeMatrixChanges)
                data["feeMatrixChanges"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFeeMatrixModel {
    id?: string | undefined;
    startDate: Date;
    endDate: Date;
    isLateEntryCharge: boolean;
    feeMatrixStatus: FeeMatrixStatus;
    code?: string | undefined;
    rejectReason?: string | undefined;
    productId: string;
    product?: ProductModel | undefined;
    feeMatrixOfficeWBSs?: FeeMatrixOfficeWBSModel[] | undefined;
    feeMatrixLateEntryCharges?: FeeMatrixLateEntryChargeModel[] | undefined;
    feeMatrixSubjects?: FeeMatrixSubjectModel[] | undefined;
    feeMatrixChanges?: FeeMatrixChangeModel[] | undefined;
}

export enum FeeMatrixStatus {
    Drafted = "Drafted",
    Submitted = "Submitted",
    Rejected = "Rejected",
    Approved = "Approved",
    Published = "Published",
    Expired = "Expired",
}

export class FeeMatrixOfficeWBSModel implements IFeeMatrixOfficeWBSModel {
    id!: string;
    wbs?: string | undefined;
    officeId!: string;
    office?: OfficeModel | undefined;
    feeMatrixId!: string;

    constructor(data?: IFeeMatrixOfficeWBSModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.wbs = _data["wbs"];
            this.officeId = _data["officeId"];
            this.office = _data["office"] ? OfficeModel.fromJS(_data["office"]) : <any>undefined;
            this.feeMatrixId = _data["feeMatrixId"];
        }
    }

    static fromJS(data: any): FeeMatrixOfficeWBSModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeeMatrixOfficeWBSModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["wbs"] = this.wbs;
        data["officeId"] = this.officeId;
        data["office"] = this.office ? this.office.toJSON() : <any>undefined;
        data["feeMatrixId"] = this.feeMatrixId;
        return data; 
    }
}

export interface IFeeMatrixOfficeWBSModel {
    id: string;
    wbs?: string | undefined;
    officeId: string;
    office?: OfficeModel | undefined;
    feeMatrixId: string;
}

export class FeeMatrixLateEntryChargeModel implements IFeeMatrixLateEntryChargeModel {
    id!: string;
    stage!: number;
    fee!: number;
    feeMatrixId!: string;

    constructor(data?: IFeeMatrixLateEntryChargeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.stage = _data["stage"];
            this.fee = _data["fee"];
            this.feeMatrixId = _data["feeMatrixId"];
        }
    }

    static fromJS(data: any): FeeMatrixLateEntryChargeModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeeMatrixLateEntryChargeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stage"] = this.stage;
        data["fee"] = this.fee;
        data["feeMatrixId"] = this.feeMatrixId;
        return data; 
    }
}

export interface IFeeMatrixLateEntryChargeModel {
    id: string;
    stage: number;
    fee: number;
    feeMatrixId: string;
}

export class FeeMatrixSubjectModel implements IFeeMatrixSubjectModel {
    id!: string;
    localFee?: number | undefined;
    boardFee?: number | undefined;
    vat?: number | undefined;
    total?: number | undefined;
    isTier!: boolean;
    isLateEntryCharge!: boolean;
    subjectId!: string;
    subject?: SubjectModel | undefined;
    feeMatrixId!: string;
    feeMatrixSubjectTiers?: FeeMatrixSubjectTierModel[] | undefined;

    constructor(data?: IFeeMatrixSubjectModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.localFee = _data["localFee"];
            this.boardFee = _data["boardFee"];
            this.vat = _data["vat"];
            this.total = _data["total"];
            this.isTier = _data["isTier"];
            this.isLateEntryCharge = _data["isLateEntryCharge"];
            this.subjectId = _data["subjectId"];
            this.subject = _data["subject"] ? SubjectModel.fromJS(_data["subject"]) : <any>undefined;
            this.feeMatrixId = _data["feeMatrixId"];
            if (Array.isArray(_data["feeMatrixSubjectTiers"])) {
                this.feeMatrixSubjectTiers = [] as any;
                for (let item of _data["feeMatrixSubjectTiers"])
                    this.feeMatrixSubjectTiers!.push(FeeMatrixSubjectTierModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): FeeMatrixSubjectModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeeMatrixSubjectModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["localFee"] = this.localFee;
        data["boardFee"] = this.boardFee;
        data["vat"] = this.vat;
        data["total"] = this.total;
        data["isTier"] = this.isTier;
        data["isLateEntryCharge"] = this.isLateEntryCharge;
        data["subjectId"] = this.subjectId;
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["feeMatrixId"] = this.feeMatrixId;
        if (Array.isArray(this.feeMatrixSubjectTiers)) {
            data["feeMatrixSubjectTiers"] = [];
            for (let item of this.feeMatrixSubjectTiers)
                data["feeMatrixSubjectTiers"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IFeeMatrixSubjectModel {
    id: string;
    localFee?: number | undefined;
    boardFee?: number | undefined;
    vat?: number | undefined;
    total?: number | undefined;
    isTier: boolean;
    isLateEntryCharge: boolean;
    subjectId: string;
    subject?: SubjectModel | undefined;
    feeMatrixId: string;
    feeMatrixSubjectTiers?: FeeMatrixSubjectTierModel[] | undefined;
}

export class FeeMatrixSubjectTierModel implements IFeeMatrixSubjectTierModel {
    id!: string;
    from!: number;
    to!: number;
    localFee?: number | undefined;
    feeMatrixSubjectId!: string;

    constructor(data?: IFeeMatrixSubjectTierModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.localFee = _data["localFee"];
            this.feeMatrixSubjectId = _data["feeMatrixSubjectId"];
        }
    }

    static fromJS(data: any): FeeMatrixSubjectTierModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeeMatrixSubjectTierModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["from"] = this.from;
        data["to"] = this.to;
        data["localFee"] = this.localFee;
        data["feeMatrixSubjectId"] = this.feeMatrixSubjectId;
        return data; 
    }
}

export interface IFeeMatrixSubjectTierModel {
    id: string;
    from: number;
    to: number;
    localFee?: number | undefined;
    feeMatrixSubjectId: string;
}

export class FeeMatrixChangeModel implements IFeeMatrixChangeModel {
    id?: string | undefined;
    comment?: string | undefined;
    lastStatus!: FeeMatrixStatus;
    feeMatrixId!: string;

    constructor(data?: IFeeMatrixChangeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.comment = _data["comment"];
            this.lastStatus = _data["lastStatus"];
            this.feeMatrixId = _data["feeMatrixId"];
        }
    }

    static fromJS(data: any): FeeMatrixChangeModel {
        data = typeof data === 'object' ? data : {};
        let result = new FeeMatrixChangeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["comment"] = this.comment;
        data["lastStatus"] = this.lastStatus;
        data["feeMatrixId"] = this.feeMatrixId;
        return data; 
    }
}

export interface IFeeMatrixChangeModel {
    id?: string | undefined;
    comment?: string | undefined;
    lastStatus: FeeMatrixStatus;
    feeMatrixId: string;
}

export class ChangeFeeMatrixStatusModel implements IChangeFeeMatrixStatusModel {
    id?: string | undefined;
    reason?: string | undefined;
    status!: FeeMatrixStatus;

    constructor(data?: IChangeFeeMatrixStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reason = _data["reason"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ChangeFeeMatrixStatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeFeeMatrixStatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reason"] = this.reason;
        data["status"] = this.status;
        return data; 
    }
}

export interface IChangeFeeMatrixStatusModel {
    id?: string | undefined;
    reason?: string | undefined;
    status: FeeMatrixStatus;
}

export class PagedResultOfFeeMatrixModel implements IPagedResultOfFeeMatrixModel {
    list?: FeeMatrixModel[] | undefined;
    pageSize!: number;
    pageIndex!: number;
    recordCount!: number;
    pageCount!: number;

    constructor(data?: IPagedResultOfFeeMatrixModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(FeeMatrixModel.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.recordCount = _data["recordCount"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultOfFeeMatrixModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfFeeMatrixModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["recordCount"] = this.recordCount;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultOfFeeMatrixModel {
    list?: FeeMatrixModel[] | undefined;
    pageSize: number;
    pageIndex: number;
    recordCount: number;
    pageCount: number;
}

export class GLAccountModel implements IGLAccountModel {
    id!: string;
    accountType!: GlAccountType;
    receiveAccount?: string | undefined;
    refundAccount?: string | undefined;

    constructor(data?: IGLAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountType = _data["accountType"];
            this.receiveAccount = _data["receiveAccount"];
            this.refundAccount = _data["refundAccount"];
        }
    }

    static fromJS(data: any): GLAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new GLAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountType"] = this.accountType;
        data["receiveAccount"] = this.receiveAccount;
        data["refundAccount"] = this.refundAccount;
        return data; 
    }
}

export interface IGLAccountModel {
    id: string;
    accountType: GlAccountType;
    receiveAccount?: string | undefined;
    refundAccount?: string | undefined;
}

export enum GlAccountType {
    LocalFee = "LocalFee",
    BoardFee = "BoardFee",
    Vat = "Vat",
}

export class PagedResultOfJournalRecordModel implements IPagedResultOfJournalRecordModel {
    list?: JournalRecordModel[] | undefined;
    pageSize!: number;
    pageIndex!: number;
    recordCount!: number;
    pageCount!: number;

    constructor(data?: IPagedResultOfJournalRecordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(JournalRecordModel.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.recordCount = _data["recordCount"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultOfJournalRecordModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfJournalRecordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["recordCount"] = this.recordCount;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultOfJournalRecordModel {
    list?: JournalRecordModel[] | undefined;
    pageSize: number;
    pageIndex: number;
    recordCount: number;
    pageCount: number;
}

export class JournalRecordModel implements IJournalRecordModel {
    orderId?: string | undefined;
    orderNo?: string | undefined;
    localFeeAmount!: number;
    boardFeeAmount!: number;
    vat!: number;
    totalAmount!: number;
    status!: boolean;
    type!: JournalType;
    completeDateTime?: Date | undefined;
    applicationId!: string;
    application?: ApplicationModel | undefined;

    constructor(data?: IJournalRecordModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderId = _data["orderId"];
            this.orderNo = _data["orderNo"];
            this.localFeeAmount = _data["localFeeAmount"];
            this.boardFeeAmount = _data["boardFeeAmount"];
            this.vat = _data["vat"];
            this.totalAmount = _data["totalAmount"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.completeDateTime = _data["completeDateTime"] ? new Date(_data["completeDateTime"].toString()) : <any>undefined;
            this.applicationId = _data["applicationId"];
            this.application = _data["application"] ? ApplicationModel.fromJS(_data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JournalRecordModel {
        data = typeof data === 'object' ? data : {};
        let result = new JournalRecordModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderId"] = this.orderId;
        data["orderNo"] = this.orderNo;
        data["localFeeAmount"] = this.localFeeAmount;
        data["boardFeeAmount"] = this.boardFeeAmount;
        data["vat"] = this.vat;
        data["totalAmount"] = this.totalAmount;
        data["status"] = this.status;
        data["type"] = this.type;
        data["completeDateTime"] = this.completeDateTime ? this.completeDateTime.toISOString() : <any>undefined;
        data["applicationId"] = this.applicationId;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IJournalRecordModel {
    orderId?: string | undefined;
    orderNo?: string | undefined;
    localFeeAmount: number;
    boardFeeAmount: number;
    vat: number;
    totalAmount: number;
    status: boolean;
    type: JournalType;
    completeDateTime?: Date | undefined;
    applicationId: string;
    application?: ApplicationModel | undefined;
}

export enum JournalType {
    Payment = "Payment",
    Refund = "Refund",
}

export class PagedResultOfOrderListModel implements IPagedResultOfOrderListModel {
    list?: OrderListModel[] | undefined;
    pageSize!: number;
    pageIndex!: number;
    recordCount!: number;
    pageCount!: number;

    constructor(data?: IPagedResultOfOrderListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(OrderListModel.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.recordCount = _data["recordCount"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultOfOrderListModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfOrderListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["recordCount"] = this.recordCount;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultOfOrderListModel {
    list?: OrderListModel[] | undefined;
    pageSize: number;
    pageIndex: number;
    recordCount: number;
    pageCount: number;
}

export class OrderListModel implements IOrderListModel {
    id!: string;
    orderNo?: string | undefined;
    payTime!: Date;
    userPhoneNumber?: string | undefined;
    amount!: number;
    status!: OrderStatus;

    constructor(data?: IOrderListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.orderNo = _data["orderNo"];
            this.payTime = _data["payTime"] ? new Date(_data["payTime"].toString()) : <any>undefined;
            this.userPhoneNumber = _data["userPhoneNumber"];
            this.amount = _data["amount"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): OrderListModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["orderNo"] = this.orderNo;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["userPhoneNumber"] = this.userPhoneNumber;
        data["amount"] = this.amount;
        data["status"] = this.status;
        return data; 
    }
}

export interface IOrderListModel {
    id: string;
    orderNo?: string | undefined;
    payTime: Date;
    userPhoneNumber?: string | undefined;
    amount: number;
    status: OrderStatus;
}

export enum OrderStatus {
    PaymentPending = "PaymentPending",
    PaymentSuccessful = "PaymentSuccessful",
    PaymentExpired = "PaymentExpired",
}

export class OrderDetailModel implements IOrderDetailModel {
    orderNo?: string | undefined;
    status!: OrderStatus;
    payRemainingTime!: number;
    totalAmount!: number;
    discountAmount!: number;
    payAmount!: number;
    orderDetails?: OrderDetailListModel[] | undefined;

    constructor(data?: IOrderDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderNo = _data["orderNo"];
            this.status = _data["status"];
            this.payRemainingTime = _data["payRemainingTime"];
            this.totalAmount = _data["totalAmount"];
            this.discountAmount = _data["discountAmount"];
            this.payAmount = _data["payAmount"];
            if (Array.isArray(_data["orderDetails"])) {
                this.orderDetails = [] as any;
                for (let item of _data["orderDetails"])
                    this.orderDetails!.push(OrderDetailListModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OrderDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderNo"] = this.orderNo;
        data["status"] = this.status;
        data["payRemainingTime"] = this.payRemainingTime;
        data["totalAmount"] = this.totalAmount;
        data["discountAmount"] = this.discountAmount;
        data["payAmount"] = this.payAmount;
        if (Array.isArray(this.orderDetails)) {
            data["orderDetails"] = [];
            for (let item of this.orderDetails)
                data["orderDetails"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IOrderDetailModel {
    orderNo?: string | undefined;
    status: OrderStatus;
    payRemainingTime: number;
    totalAmount: number;
    discountAmount: number;
    payAmount: number;
    orderDetails?: OrderDetailListModel[] | undefined;
}

export class OrderDetailListModel implements IOrderDetailListModel {
    id!: string;
    productName?: string | undefined;
    subjectName?: string | undefined;
    examDate!: Date;
    examStartTime!: string;
    examEndTime!: string;
    cityName?: string | undefined;
    candidateName?: string | undefined;
    code?: string | undefined;
    fee!: number;

    constructor(data?: IOrderDetailListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.subjectName = _data["subjectName"];
            this.examDate = _data["examDate"] ? new Date(_data["examDate"].toString()) : <any>undefined;
            this.examStartTime = _data["examStartTime"];
            this.examEndTime = _data["examEndTime"];
            this.cityName = _data["cityName"];
            this.candidateName = _data["candidateName"];
            this.code = _data["code"];
            this.fee = _data["fee"];
        }
    }

    static fromJS(data: any): OrderDetailListModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderDetailListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["subjectName"] = this.subjectName;
        data["examDate"] = this.examDate ? this.examDate.toISOString() : <any>undefined;
        data["examStartTime"] = this.examStartTime;
        data["examEndTime"] = this.examEndTime;
        data["cityName"] = this.cityName;
        data["candidateName"] = this.candidateName;
        data["code"] = this.code;
        data["fee"] = this.fee;
        return data; 
    }
}

export interface IOrderDetailListModel {
    id: string;
    productName?: string | undefined;
    subjectName?: string | undefined;
    examDate: Date;
    examStartTime: string;
    examEndTime: string;
    cityName?: string | undefined;
    candidateName?: string | undefined;
    code?: string | undefined;
    fee: number;
}

export class PaymentChannelModel implements IPaymentChannelModel {
    id!: string;
    channelType!: ChannelType;
    rate!: number;

    constructor(data?: IPaymentChannelModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.channelType = _data["channelType"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): PaymentChannelModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentChannelModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["channelType"] = this.channelType;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IPaymentChannelModel {
    id: string;
    channelType: ChannelType;
    rate: number;
}

export enum ChannelType {
    BankGateway = "BankGateway",
    UnionPayExpress = "UnionPayExpress",
    UnionPayQR = "UnionPayQR",
    WechatQR = "WechatQR",
    AlipayQR = "AlipayQR",
    PayeaseH5 = "PayeaseH5",
    VisaOrMaster = "VisaOrMaster",
}

export class ProductFeeMatrixModel implements IProductFeeMatrixModel {
    id!: string;
    productName?: string | undefined;
    feeMatrixId!: string;

    constructor(data?: IProductFeeMatrixModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.productName = _data["productName"];
            this.feeMatrixId = _data["feeMatrixId"];
        }
    }

    static fromJS(data: any): ProductFeeMatrixModel {
        data = typeof data === 'object' ? data : {};
        let result = new ProductFeeMatrixModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["productName"] = this.productName;
        data["feeMatrixId"] = this.feeMatrixId;
        return data; 
    }
}

export interface IProductFeeMatrixModel {
    id: string;
    productName?: string | undefined;
    feeMatrixId: string;
}

export class PagedResultOfRefundListModel implements IPagedResultOfRefundListModel {
    list?: RefundListModel[] | undefined;
    pageSize!: number;
    pageIndex!: number;
    recordCount!: number;
    pageCount!: number;

    constructor(data?: IPagedResultOfRefundListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(RefundListModel.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.recordCount = _data["recordCount"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultOfRefundListModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRefundListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["recordCount"] = this.recordCount;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultOfRefundListModel {
    list?: RefundListModel[] | undefined;
    pageSize: number;
    pageIndex: number;
    recordCount: number;
    pageCount: number;
}

export class RefundListModel implements IRefundListModel {
    id!: string;
    applicationId?: string | undefined;
    office?: string | undefined;
    product?: string | undefined;
    customer?: string | undefined;
    orderNo?: string | undefined;
    payment!: number;
    refund!: number;
    submittedTime?: Date | undefined;
    status!: ApplicationRefundStatus;

    constructor(data?: IRefundListModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.applicationId = _data["applicationId"];
            this.office = _data["office"];
            this.product = _data["product"];
            this.customer = _data["customer"];
            this.orderNo = _data["orderNo"];
            this.payment = _data["payment"];
            this.refund = _data["refund"];
            this.submittedTime = _data["submittedTime"] ? new Date(_data["submittedTime"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): RefundListModel {
        data = typeof data === 'object' ? data : {};
        let result = new RefundListModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["applicationId"] = this.applicationId;
        data["office"] = this.office;
        data["product"] = this.product;
        data["customer"] = this.customer;
        data["orderNo"] = this.orderNo;
        data["payment"] = this.payment;
        data["refund"] = this.refund;
        data["submittedTime"] = this.submittedTime ? this.submittedTime.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }
}

export interface IRefundListModel {
    id: string;
    applicationId?: string | undefined;
    office?: string | undefined;
    product?: string | undefined;
    customer?: string | undefined;
    orderNo?: string | undefined;
    payment: number;
    refund: number;
    submittedTime?: Date | undefined;
    status: ApplicationRefundStatus;
}

export class UpdateApplicationRefundStatusModel implements IUpdateApplicationRefundStatusModel {
    id?: string | undefined;
    reason?: string | undefined;
    status!: ApplicationRefundStatus;

    constructor(data?: IUpdateApplicationRefundStatusModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.reason = _data["reason"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateApplicationRefundStatusModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationRefundStatusModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["reason"] = this.reason;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateApplicationRefundStatusModel {
    id?: string | undefined;
    reason?: string | undefined;
    status: ApplicationRefundStatus;
}

export class PaymentRefundModel implements IPaymentRefundModel {
    status?: string | undefined;
    refundAmount!: number;

    constructor(data?: IPaymentRefundModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.refundAmount = _data["refundAmount"];
        }
    }

    static fromJS(data: any): PaymentRefundModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentRefundModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["refundAmount"] = this.refundAmount;
        return data; 
    }
}

export interface IPaymentRefundModel {
    status?: string | undefined;
    refundAmount: number;
}

export class PagedResultOfSessionModel implements IPagedResultOfSessionModel {
    list?: SessionModel[] | undefined;
    pageSize!: number;
    pageIndex!: number;
    recordCount!: number;
    pageCount!: number;

    constructor(data?: IPagedResultOfSessionModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(SessionModel.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.recordCount = _data["recordCount"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultOfSessionModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfSessionModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["recordCount"] = this.recordCount;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultOfSessionModel {
    list?: SessionModel[] | undefined;
    pageSize: number;
    pageIndex: number;
    recordCount: number;
    pageCount: number;
}

export class ResultMessageOfSessionConfirmationModel implements IResultMessageOfSessionConfirmationModel {
    isSuccessful!: boolean;
    message?: string | undefined;
    code!: GetConfirmationLetterResultType;
    tModel?: SessionConfirmationModel | undefined;

    constructor(data?: IResultMessageOfSessionConfirmationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"];
            this.message = _data["message"];
            this.code = _data["code"];
            this.tModel = _data["tModel"] ? SessionConfirmationModel.fromJS(_data["tModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResultMessageOfSessionConfirmationModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultMessageOfSessionConfirmationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful;
        data["message"] = this.message;
        data["code"] = this.code;
        data["tModel"] = this.tModel ? this.tModel.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IResultMessageOfSessionConfirmationModel {
    isSuccessful: boolean;
    message?: string | undefined;
    code: GetConfirmationLetterResultType;
    tModel?: SessionConfirmationModel | undefined;
}

export enum GetConfirmationLetterResultType {
    VenueNotSet = "VenueNotSet",
    NoMailNeedToSend = "NoMailNeedToSend",
}

export class SessionConfirmationModel implements ISessionConfirmationModel {
    followingSessionName?: string | undefined;
    venueName?: string | undefined;
    subjectNames?: string[] | undefined;
    registeredCddNumber!: number;
    pendingTaskNumber!: number;

    constructor(data?: ISessionConfirmationModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.followingSessionName = _data["followingSessionName"];
            this.venueName = _data["venueName"];
            if (Array.isArray(_data["subjectNames"])) {
                this.subjectNames = [] as any;
                for (let item of _data["subjectNames"])
                    this.subjectNames!.push(item);
            }
            this.registeredCddNumber = _data["registeredCddNumber"];
            this.pendingTaskNumber = _data["pendingTaskNumber"];
        }
    }

    static fromJS(data: any): SessionConfirmationModel {
        data = typeof data === 'object' ? data : {};
        let result = new SessionConfirmationModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["followingSessionName"] = this.followingSessionName;
        data["venueName"] = this.venueName;
        if (Array.isArray(this.subjectNames)) {
            data["subjectNames"] = [];
            for (let item of this.subjectNames)
                data["subjectNames"].push(item);
        }
        data["registeredCddNumber"] = this.registeredCddNumber;
        data["pendingTaskNumber"] = this.pendingTaskNumber;
        return data; 
    }
}

export interface ISessionConfirmationModel {
    followingSessionName?: string | undefined;
    venueName?: string | undefined;
    subjectNames?: string[] | undefined;
    registeredCddNumber: number;
    pendingTaskNumber: number;
}

export enum CandidateType {
    ACCA = "ACCA",
    FIA = "FIA",
}

export class PagedResultOfVenueModel implements IPagedResultOfVenueModel {
    list?: VenueModel[] | undefined;
    pageSize!: number;
    pageIndex!: number;
    recordCount!: number;
    pageCount!: number;

    constructor(data?: IPagedResultOfVenueModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["list"])) {
                this.list = [] as any;
                for (let item of _data["list"])
                    this.list!.push(VenueModel.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            this.pageIndex = _data["pageIndex"];
            this.recordCount = _data["recordCount"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultOfVenueModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfVenueModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.list)) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        data["pageIndex"] = this.pageIndex;
        data["recordCount"] = this.recordCount;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedResultOfVenueModel {
    list?: VenueModel[] | undefined;
    pageSize: number;
    pageIndex: number;
    recordCount: number;
    pageCount: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}